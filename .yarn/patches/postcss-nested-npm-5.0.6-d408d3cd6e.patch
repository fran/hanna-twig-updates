diff --git a/README.md b/README.md
index 118ae202263e9a619b773caf0e77384578a51b2b..e0282c77fb4446f87dc4f1501e594c50015c93f1 100644
--- a/README.md
+++ b/README.md
@@ -81,7 +81,7 @@ Alternatives:
 [`postcss-current-selector`]: https://github.com/komlev/postcss-current-selector
 [`postcss-nested-ancestors`]: https://github.com/toomuchdesign/postcss-nested-ancestors
 [`postcss-nested-props`]:     https://github.com/jedmao/postcss-nested-props
-[`postcss-nesting`]:          https://github.com/jonathantneal/postcss-nesting
+[`postcss-nesting`]:          https://github.com/csstools/postcss-plugins/tree/main/plugins/postcss-nesting
 [CSSWG draft]:              https://drafts.csswg.org/css-nesting-1/
 [PostCSS]:                  https://github.com/postcss/postcss
 
@@ -119,8 +119,8 @@ module.exports = {
 
 ### `bubble`
 
-By default, plugin will bubble only `@media` and `@supports` at-rules.
-You can add your custom at-rules to this list by `bubble` option:
+By default, plugin will bubble only `@media`, `@supports` and `@layer`
+at-rules. Use this option to add your custom at-rules to this list.
 
 ```js
 postcss([ require('postcss-nested')({ bubble: ['phone'] }) ])
@@ -196,3 +196,27 @@ Will be compiled to:
 ```
 
 This is especially useful if you want to export the empty classes with `postcss-modules`.
+
+
+### `rootRuleName`
+
+The plugin supports the SCSS custom at-rule `@at-root` which breaks rule
+blocks out of their nested position. If you want, you can choose a new
+custom name for this rule in your code.
+
+```js
+postcss([ require('postcss-nested')({ rootRuleName: '_escape-nesting' }) ])
+```
+
+```css
+/* input */
+.a {
+  color: white;
+  @_escape-nesting {
+    .b { color: black; }
+  }
+}
+/* output */
+.a { color: white; }
+.b { color: black; }
+```
diff --git a/index.d.ts b/index.d.ts
index d22bcdd4a8c12f7dc47bd17db6e91445d890a86e..536768269733e83f1b9012c85da3c9df2fc9eef5 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -6,8 +6,8 @@ import { PluginCreator } from 'postcss'
 declare namespace nested {
   interface Options {
     /**
-     * By default, plugin will bubble only `@media` and `@supports` at-rules.
-     * You can add your custom at-rules to this list by this option.
+     * By default, plugin will bubble only `@media`, `@supports` and `@layer`
+     * at-rules. Use this option to add your custom at-rules to this list.
      */
     bubble?: string[]
 
@@ -24,6 +24,13 @@ declare namespace nested {
      * to preserve them.
      */
     preserveEmpty?: boolean
+
+    /**
+     * The plugin supports the SCSS custom at-rule `@at-root` which breaks
+     * rule blocks out of their nested position. If you want, you can choose
+     * a new custom name for this rule in your code.
+     */
+    rootRuleName?: string
   }
 
   type Nested = PluginCreator<Options>
diff --git a/index.js b/index.js
index e6ebd9261409d1f2ac4a689dba0046535c16fcbc..8af3027280e6f40e78df29015758f88fe009e434 100644
--- a/index.js
+++ b/index.js
@@ -1,14 +1,41 @@
+// @ts-check
+const { Rule } = require('postcss')
 let parser = require('postcss-selector-parser')
 
-function parse (str, rule) {
+/** @typedef {import('postcss').Container}  Container */
+/** @typedef {import('postcss').ChildNode}  ChildNode */
+/** @typedef {import('postcss').Comment}  Comment */
+/** @typedef {import('postcss').Declaration}  Declaration */
+/** @typedef {import('postcss').Rule}  PostcssRule */
+/** @typedef {import('postcss').AtRule}  AtRule */
+/** @typedef {typeof import('postcss').Rule}  RuleConstructor */
+/** @typedef {parser.Root}  Root */
+/** @typedef {parser.Node}  Node */
+/** @typedef {parser.Selector}  Selector */
+/** @typedef {Record<string, true>}  RuleMap  Simple lookup table for \@-rules */
+
+/**
+ * Run a selector string through postcss-selector-parser
+ *
+ * @param {string} rawSelector
+ * @param {PostcssRule} [rule]
+ * @returns {Selector}
+ */
+function parse(rawSelector, rule) {
+  /** @type {parser.Root | undefined} */
   let nodes
   let saver = parser(parsed => {
     nodes = parsed
   })
   try {
-    saver.processSync(str)
+    saver.processSync(rawSelector)
+    if (typeof nodes === 'undefined') {
+      // Should never happen but @ts-check can't deduce the side-effect
+      // triggered by `saver.processSync(str)`
+      throw new Error('Parsing failed')
+    }
   } catch (e) {
-    if (str.includes(':')) {
+    if (rawSelector.includes(':')) {
       throw rule ? rule.error('Missed semicolon') : e
     } else {
       throw rule ? rule.error(e.message) : e
@@ -17,71 +44,114 @@ function parse (str, rule) {
   return nodes.at(0)
 }
 
-function replace (nodes, parent) {
+/**
+ * Replaces the "&" token in a node's selector with the parent selector
+ * similar to what SCSS does.
+ *
+ * Mutates the nodes list
+ *
+ * @param {Extract<Node, { nodes: Array }>} nodes
+ * @param {Selector} parent
+ * @returns {boolean} Indicating whether a replacement took place or not.
+ */
+function interpolateAmpInSelector(nodes, parent) {
   let replaced = false
-  nodes.each(i => {
-    if (i.type === 'nesting') {
-      let clonedParent = parent.clone()
-      if (i.value !== '&') {
-        i.replaceWith(parse(i.value.replace('&', clonedParent.toString())))
-      } else {
-        i.replaceWith(clonedParent)
-      }
-      replaced = true
-    } else if (i.nodes) {
-      if (replace(i, parent)) {
+  nodes.each(
+    /** @type {Node} */ node => {
+      if (node.type === 'nesting') {
+        let clonedParent = parent.clone({})
+        if (node.value !== '&') {
+          node.replaceWith(
+            parse(node.value.replace('&', clonedParent.toString()))
+          )
+        } else {
+          node.replaceWith(clonedParent)
+        }
         replaced = true
+      } else if ('nodes' in node && node.nodes) {
+        if (interpolateAmpInSelector(node, parent)) {
+          replaced = true
+        }
       }
     }
-  })
+  )
   return replaced
 }
 
-function selectors (parent, child) {
-  let result = []
-  parent.selectors.forEach(i => {
-    let parentNode = parse(i, parent)
-
-    child.selectors.forEach(j => {
-      if (j.length) {
-        let node = parse(j, child)
-        let replaced = replace(node, parentNode)
-        if (!replaced) {
-          node.prepend(parser.combinator({ value: ' ' }))
-          node.prepend(parentNode.clone())
-        }
-        result.push(node.toString())
+/**
+ * Combines parent and child selectors, in a SCSS-like way
+ *
+ * @param {PostcssRule} parent
+ * @param {PostcssRule} child
+ * @returns {Array<string>} An array of new, merged selectors
+ */
+function mergeSelectors(parent, child) {
+  /** @type {Array<string>} */
+  let merged = []
+  parent.selectors.forEach(sel => {
+    let parentNode = parse(sel, parent)
+
+    child.selectors.forEach(selector => {
+      if (!selector) {
+        return
+      }
+      let node = parse(selector, child)
+      let replaced = interpolateAmpInSelector(node, parentNode)
+      if (!replaced) {
+        // NOTE: The type definitions for `postcss-selector-parser` seem to be
+        // badly outdated.
+        node.prepend(/** @type {any} */ (parser.combinator({ value: ' ' })))
+        node.prepend(/** @type {Selector} */ (parentNode.clone({})))
       }
+      merged.push(node.toString())
     })
   })
-  return result
+  return merged
 }
 
-function pickComment (comment, after) {
-  if (comment && comment.type === 'comment') {
-    after.after(comment)
-    return comment
-  } else {
-    return after
+/**
+ * Move a child and its preceeding comment(s) to after "after"
+ *
+ * @param {ChildNode} child
+ * @param {ChildNode} after
+ * @returns {ChildNode} updated "after" node
+ */
+function breakOut(child, after) {
+  let prev = child.prev()
+  after.after(child)
+  while (prev && prev.type === 'comment') {
+    let nextPrev = prev.prev()
+    after.after(prev)
+    prev = nextPrev
   }
+  return child
 }
 
-function createFnAtruleChilds (bubble) {
-  return function atruleChilds (rule, atrule, bubbling) {
+/**
+ * @param {RuleMap} bubble
+ */
+function createFnAtruleChilds(bubble) {
+  /**
+   * @param {PostcssRule} rule
+   * @param {AtRule} atrule
+   * @param {boolean} bubbling
+   */
+  return function atruleChilds(rule, atrule, bubbling, mergeSels = bubbling) {
+    /** @type {Array<ChildNode>} */
     let children = []
     atrule.each(child => {
-      if (child.type === 'comment') {
-        children.push(child)
-      } else if (child.type === 'decl') {
-        children.push(child)
-      } else if (child.type === 'rule' && bubbling) {
-        child.selectors = selectors(rule, child)
-      } else if (child.type === 'atrule') {
-        if (child.nodes && bubble[child.name]) {
-          atruleChilds(rule, child, true)
-        } else {
+      if (child.type === 'rule' && bubbling) {
+        if (mergeSels) {
+          child.selectors = mergeSelectors(rule, child)
+        }
+      } else if (child.type === 'atrule' && child.nodes) {
+        if (bubble[child.name]) {
+          atruleChilds(rule, child, mergeSels)
+        } else if (atrule[rootRuleMergeSel] !== false) {
           children.push(child)
         }
+      } else {
+        children.push(child)
       }
     })
     if (bubbling) {
@@ -96,36 +166,199 @@ function createFnAtruleChilds (bubble) {
   }
 }
 
-function pickDeclarations (selector, declarations, after, Rule) {
+/**
+ * @param {string} selector
+ * @param {Array<ChildNode>} declarations
+ * @param {ChildNode} after
+ * @param {RuleConstructor} Rule
+ */
+function pickDeclarations(selector, declarations, after, Rule) {
   let parent = new Rule({
     selector,
     nodes: []
   })
-
-  for (let declaration of declarations) {
-    parent.append(declaration)
-  }
-
+  parent.append(declarations)
   after.after(parent)
   return parent
 }
 
-function atruleNames (defaults, custom) {
+/**
+ * @param {Array<string>} defaults,
+ * @param {Array<string>} [custom]
+ */
+function atruleNames(defaults, custom) {
+  /** @type {RuleMap} */
   let list = {}
-  for (let i of defaults) {
-    list[i] = true
+  for (let name of defaults) {
+    list[name] = true
   }
   if (custom) {
-    for (let i of custom) {
-      let name = i.replace(/^@/, '')
-      list[name] = true
+    for (let name of custom) {
+      list[name.replace(/^@/, '')] = true
     }
   }
   return list
 }
 
+/** @typedef {{ type: 'basic', selector?: string, escapes?: never }}  AtRootBParams */
+/** @typedef {{ type: 'withrules', escapes: (rule: string) => boolean, selector?: never }}  AtRootWParams */
+/** @typedef {{ type: 'unknown', selector?: never, escapes?: never }}  AtRootUParams */
+/** @typedef {{ type: 'noop', selector?: never, escapes?: never }}  AtRootNParams */
+/** @typedef {AtRootBParams | AtRootWParams | AtRootNParams | AtRootUParams}  AtRootParams */
+
+/** @type {(params: string) => AtRootParams } */
+function parseRootRuleParams(params) {
+  params = params.trim()
+  let braceBlock = params.match(/^\((.*)\)$/)
+  if (!braceBlock) {
+    return { type: 'basic', selector: params }
+  }
+  let bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/)
+  if (bits) {
+    let allowlist = bits[1] === 'with'
+    /** @type {RuleMap} */
+    let rules = Object.fromEntries(
+      bits[2]
+        .trim()
+        .split(/\s+/)
+        .map(name => [name, true])
+    )
+    if (allowlist && rules.all) {
+      return { type: 'noop' }
+    }
+    return {
+      type: 'withrules',
+      escapes: rules.all
+        ? () => true
+        : allowlist
+        ? rule => (rule === 'all' ? false : !rules[rule])
+        : rule => !!rules[rule]
+    }
+  }
+  // Unrecognized brace block
+  return { type: 'unknown' }
+}
+
+/**
+ * @param {AtRule} leaf
+ * @returns {Array<AtRule>}
+ */
+function getAncestorRules(leaf) {
+  /** @type {Array<AtRule>} */
+  const lineage = []
+  /** @type {Container<ChildNode> | ChildNode | Document | undefined} */
+  let parent
+  parent = leaf.parent
+
+  while (parent) {
+    if (parent.type === 'atrule') {
+      lineage.push(/** @type {AtRule} */ (parent))
+    }
+    parent = parent.parent
+  }
+  return lineage
+}
+
+/**
+ * @param {AtRule} rule
+ */
+function unwrapRootRule(rule) {
+  const escapes = rule[rootRuleEscapes]
+
+  if (!escapes) {
+    rule.after(rule.nodes)
+  } else {
+    const nodes = rule.nodes
+
+    /** @type {AtRule | undefined} */
+    let topEscaped
+    let topEscapedIdx = -1
+    /** @type {AtRule | undefined} */
+    let breakoutLeaf
+    /** @type {AtRule | undefined} */
+    let breakoutRoot
+    /** @type {AtRule | undefined} */
+    let clone
+
+    const lineage = getAncestorRules(rule)
+    lineage.forEach((parent, i) => {
+      if (escapes(parent.name)) {
+        topEscaped = parent
+        topEscapedIdx = i
+        breakoutRoot = clone
+      } else {
+        const oldClone = clone
+        clone = parent.clone({ nodes: [] })
+        oldClone && clone.append(oldClone)
+        breakoutLeaf = breakoutLeaf || clone
+      }
+    })
+
+    if (!topEscaped) {
+      rule.after(nodes)
+    } else if (!breakoutRoot) {
+      topEscaped.after(nodes)
+    } else {
+      const leaf = /** @type {AtRule} */ (breakoutLeaf)
+      leaf.append(nodes)
+      topEscaped.after(breakoutRoot)
+    }
+
+    if (rule.next() && topEscaped) {
+      /** @type {AtRule | undefined} */
+      let restRoot
+      lineage.slice(0, topEscapedIdx + 1).forEach((parent, i, arr) => {
+        const oldRoot = restRoot
+        restRoot = parent.clone({ nodes: [] })
+        oldRoot && restRoot.append(oldRoot)
+
+        /** @type {Array<ChildNode>} */
+        let nextSibs = []
+        let _child = arr[i - 1] || rule
+        let next = _child.next()
+        while (next) {
+          nextSibs.push(next)
+          next = next.next()
+        }
+        restRoot.append(nextSibs)
+      })
+      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot)
+    }
+  }
+
+  rule.remove()
+}
+
+const rootRuleMergeSel = Symbol('rootRuleMergeSel')
+const rootRuleEscapes = Symbol('rootRuleEscapes')
+
+/**
+ * @param {AtRule} rule
+ */
+function normalizeRootRule(rule) {
+  let { params } = rule
+  const { type, selector, escapes } = parseRootRuleParams(params)
+  if (type === 'unknown') {
+    throw rule.error(
+      `Unknown @${rule.name} parameter ${JSON.stringify(params)}`
+    )
+  }
+  if (type === 'basic' && selector) {
+    let selectorBlock = new Rule({ selector: selector, nodes: rule.nodes })
+    rule.removeAll()
+    rule.append(selectorBlock)
+  }
+  rule[rootRuleEscapes] = escapes
+  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop'
+}
+
+const hasRootRule = Symbol('hasRootRule')
+
+// ---------------------------------------------------------------------------
+
+/** @type {import('./').Nested} */
 module.exports = (opts = {}) => {
-  let bubble = atruleNames(['media', 'supports'], opts.bubble)
+  let bubble = atruleNames(['media', 'supports', 'layer'], opts.bubble)
   let atruleChilds = createFnAtruleChilds(bubble)
   let unwrap = atruleNames(
     [
@@ -137,14 +370,27 @@ module.exports = (opts = {}) => {
     ],
     opts.unwrap
   )
+  let rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '')
   let preserveEmpty = opts.preserveEmpty
 
   return {
     postcssPlugin: 'postcss-nested',
-    Rule (rule, { Rule }) {
+
+    Once(root) {
+      root.walk(node => {
+        if (node.type === 'atrule' && node.name === rootRuleName) {
+          normalizeRootRule(node)
+          root[hasRootRule] = true
+        }
+      })
+    },
+
+    Rule(rule, { Rule }) {
       let unwrapped = false
+      /** @type {ChildNode} */
       let after = rule
       let copyDeclarations = false
+      /** @type {Array<ChildNode>} */
       let declarations = []
 
       rule.each(child => {
@@ -156,42 +402,27 @@ module.exports = (opts = {}) => {
 
           copyDeclarations = true
           unwrapped = true
-          child.selectors = selectors(rule, child)
-          after = pickComment(child.prev(), after)
-          after.after(child)
-          after = child
+          child.selectors = mergeSelectors(rule, child)
+          after = breakOut(child, after)
         } else if (child.type === 'atrule') {
           if (declarations.length) {
             after = pickDeclarations(rule.selector, declarations, after, Rule)
             declarations = []
           }
-
-          if (child.name === 'at-root') {
+          if (child.name === rootRuleName) {
             unwrapped = true
-            atruleChilds(rule, child, false)
-
-            let nodes = child.nodes
-            if (child.params) {
-              nodes = new Rule({ selector: child.params, nodes })
-            }
-
-            after.after(nodes)
-            after = nodes
-            child.remove()
+            atruleChilds(rule, child, true, child[rootRuleMergeSel])
+            after = breakOut(child, after)
           } else if (bubble[child.name]) {
             copyDeclarations = true
             unwrapped = true
             atruleChilds(rule, child, true)
-            after = pickComment(child.prev(), after)
-            after.after(child)
-            after = child
+            after = breakOut(child, after)
           } else if (unwrap[child.name]) {
             copyDeclarations = true
             unwrapped = true
             atruleChilds(rule, child, false)
-            after = pickComment(child.prev(), after)
-            after.after(child)
-            after = child
+            after = breakOut(child, after)
           } else if (copyDeclarations) {
             declarations.push(child)
           }
@@ -208,6 +439,17 @@ module.exports = (opts = {}) => {
         rule.raws.semicolon = true
         if (rule.nodes.length === 0) rule.remove()
       }
+    },
+
+    RootExit(root) {
+      if (root[hasRootRule]) {
+        root.walk(node => {
+          if (node.type === 'atrule' && node.name === rootRuleName) {
+            unwrapRootRule(node)
+          }
+        })
+        root[hasRootRule] = false
+      }
     }
   }
 }

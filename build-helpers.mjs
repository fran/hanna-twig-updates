// @ts-check
/* eslint-env es2022 */
import { exec as execAsync, execSync } from 'child_process';
import esbuild from 'esbuild';
import { readFileSync, writeFileSync } from 'fs';
import { access, mkdir, readFile, writeFile } from 'fs/promises';
import glob from 'glob';
import { dirname } from 'path';

/** @type {Record<string,unknown>} */
export const opts = process.argv.slice(2).reduce((map, arg) => {
  const [key, value] = arg.replace(/^-+/, '').split('=');
  map[key] = value == null ? true : value;
  return map;
}, {});

export const testsDir = '__tests';
export const distDir = '_npm-lib';
export const srcDir = 'src';

// ---------------------------------------------------------------------------

export const exit1 = (err) => {
  console.error(err);

  process.exit(1);
};

// ---------------------------------------------------------------------------

const makePackageJson = (
  /** @type {Record<string, unknown>} */ pkg,
  /** @type {string} */ outDir,
  /** @type {Record<string, unknown> | undefined} */ extraFields
) => {
  const newPkg = { ...pkg };
  const { publishConfig } = newPkg;
  delete newPkg.publishConfig;

  delete newPkg.scripts;
  delete newPkg.hxmstyle;
  delete newPkg.private;
  delete newPkg.devDependencies;
  Object.assign(newPkg, publishConfig, extraFields);

  writeFileSync(outDir + '/package.json', JSON.stringify(newPkg, null, '\t'));
};

// ---------------------------------------------------------------------------

const fileMem = {};
export const isNewFile = ({ path }) => {
  if (path in fileMem) {
    return false;
  }
  fileMem[path] = true;
  return true;
};

const writeOnlyAffected = (res, err) => {
  if (err) {
    return;
  }
  return res.outputFiles.filter(isNewFile).forEach((res) => {
    const targetDir = dirname(res.path);
    return access(targetDir)
      .catch(() => mkdir(targetDir, { recursive: true }))
      .then(() => writeFile(res.path, res.text));
  });
};

// ---------------------------------------------------------------------------

const [pkg, rootPkg] = await Promise.all([
  readFile('./package.json').then((str) => JSON.parse(str.toString())),
  readFile('../../package.json').then((str) => JSON.parse(str.toString())),
]);

export const externalDeps = [
  ...Object.keys(pkg.dependencies || {}),
  ...Object.keys(pkg.devDependencies || {}),
  ...Object.keys(rootPkg.dependencies || {}),
  ...Object.keys(rootPkg.devDependencies || {}),
].filter((name) => !name.startsWith('@reykjavik/hanna-'));

export const buildTests = () => {
  execSync(`rm -rf ${testsDir} && mkdir ${testsDir}`);

  esbuild
    .build({
      bundle: true,
      external: externalDeps,
      format: 'cjs',
      platform: 'node',
      target: ['node16'],
      entryPoints: glob.sync(`${srcDir}/**/*.tests.{js,ts,tsx}`),
      entryNames: '[dir]/[hash]__[name]',
      write: false,
      watch: !!opts.dev && {
        onRebuild: (err, results) => writeOnlyAffected(results, err),
      },
      outdir: testsDir,
    })
    .then(writeOnlyAffected)
    .catch(exit1);
};

// ---------------------------------------------------------------------------

/** @typedef {{ compilerOptions: Record<string, unknown>; include: string[]; exlude?: string[] }}  TSConfig */
const tscBuild = (
  /** @type {string} */ name,
  /** @type {TSConfig | undefined} */ config,
  /** @type {boolean | undefined} */ watch
) => {
  const cfgFile = `tsconfig.build.${name}.json`;
  writeFileSync(
    cfgFile,
    `// This file is auto-generated by build.mjs\n${JSON.stringify(
      { extends: './tsconfig.json', ...config },
      null,
      '\t'
    )}`
  );
  if (watch) {
    execAsync(`yarn run -T tsc --project ${cfgFile} --watch --preserveWatchOutput`);
  } else {
    execSync(`yarn run -T tsc --project ${cfgFile}`);
  }
};

// ---------------------------------------------------------------------------

const addReferenePathsToIndex = (
  /** @type {Array<string>} */ entryPoints,
  /** @type {string} */ distFolder
) => {
  const dtsify = (tsFilePath) => tsFilePath.replace(/\.(tsx?)$/, '.d.$1');
  const indexTsFile = entryPoints.find((filePath) =>
    /(?:^|\/)index.tsx?$/.test(filePath)
  );

  if (indexTsFile) {
    const extraEntryPaths = entryPoints
      .filter((filePath) => filePath !== indexTsFile)
      .map(dtsify)
      .map((declFile) => `/// <reference path="./${declFile}" />`);
    if (extraEntryPaths.length > 0) {
      const indexDeclFile = `${distFolder}/${dtsify(indexTsFile)}`;
      const indexDecls =
        extraEntryPaths.join('\n') + `\n\n` + readFileSync(indexDeclFile);
      writeFileSync(indexDeclFile, indexDecls);
    }
  }
};

// ---------------------------------------------------------------------------

/** @typedef {{ src?: string, cpCmds?: Array<string>, entryGlobs?: Array<string>, sideEffects?: boolean }}  BuildOpts */
/** @type {(libName: string, custom?: BuildOpts) => void} */
export const buildNpmLib = (libName, custom) => {
  const {
    src = srcDir,
    cpCmds = [`cp README.md  CHANGELOG.md ${distDir}`],
    entryGlobs = [`*.{ts,tsx}`],
    sideEffects = false,
  } = custom || {};

  const entryPoints = entryGlobs.flatMap((entryGlob) =>
    glob.sync(entryGlob, {
      cwd: src,
      ignore: ['**/*.{tests,privates}.{ts,tsx}', '**/_*'],
    })
  );

  if (!opts.dev) {
    if (!libName) {
      throw new Error('`libName` argument is required');
    }
    execSync(
      [`rm -rf ${distDir}`, `mkdir ${distDir}`].concat(cpCmds).join(' && ')
      // [`rm -rf ${distDir}`, `mkdir ${distDir} ${distDir}/esm`].concat(cpCmds).join(' && ')
    );
    // writeFile(`${distDir}/esm/package.json`, JSON.stringify({ type: 'module' }));

    makePackageJson(pkg, distDir, {
      sideEffects,
      // exports: entryPoints.reduce((exports, file) => {
      //   const token = file.replace(/\.tsx?$/, '');
      //   const expToken = token === 'index' ? '.' : `./${token}`;
      //   exports[expToken] = {
      //     import: `./esm/${token}.js`,
      //     require: `./${token}.js`,
      //   };
      //   return exports;
      // }, {}),
    });

    // -------
    [
      { name: 'cjs', module: 'commonjs' },
      // { name: 'esm', module: 'esnext' },
    ].forEach(({ name, module }) => {
      const tempOutDir = `${distDir}/temp`;
      const tempLibRoot = `${tempOutDir}/hanna-${libName}/${src}`;
      tscBuild(`lib-${name}`, {
        compilerOptions: {
          module,
          declaration: true,
          outDir: tempOutDir,
        },
        include: entryPoints.map((file) => `${src}/${file}`),
      });
      addReferenePathsToIndex(entryPoints, tempLibRoot);

      const rootDir = module === 'esnext' ? 'esm' : '.';
      execSync(
        [
          `mv ${tempLibRoot}/* ${distDir}/${rootDir}`,
          `rm -rf ${tempOutDir}`,
          // â€¦
        ].join(' && ')
      );
    });
    return;
  } else {
    execSync(`rm -rf ${distDir}`);
  }
};
